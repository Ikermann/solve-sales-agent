import React, { useState, useEffect, useRef } from 'react';

// Environment variables and configuration
const apiKey = import.meta.env.VITE_CLAUDE_API_KEY;
const hasApiKey = !!apiKey;

// --- Constants ---
const COACH_ROLE_NAME = "Sales Coach";

// [Previous SOLVE_STEPS_DATA and other constants remain the same...]

/**
 * Handles API calls to Claude for the sales agent responses
 */
const callClaude = async (history, systemInstruction, isFinalCall = false) => {
    if (!apiKey) {
        throw new Error('Claude API key is not configured. Please set VITE_CLAUDE_API_KEY in your .env file.');
    }

    const model = 'claude-3-opus-20240229'; // or 'claude-3-sonnet-20240229' for lower cost
    const apiUrl = 'https://api.anthropic.com/v1/messages';
    const maxRetries = 3;
    const baseDelay = 1000;

    console.log('Preparing Claude API request:', {
        model,
        historyLength: history.length,
        isFinalCall
    });

    // Convert history to Claude's message format
    const messages = history.map(msg => ({
        role: msg.role === 'user' ? 'user' : 'assistant',
        content: msg.parts[0].text
    }));

    // Add system instruction if present
    if (systemInstruction) {
        messages.unshift({
            role: 'system',
            content: `${systemInstruction}
            You MUST respond in JSON format following this schema:
            {
                "persona_response": "your in-character response as the prospect",
                "solve_status": {
                    "s_spotted_pain_point": boolean,
                    "o_outlined_specific_outcome": boolean,
                    "l_limited_risk_with_guarantees": boolean,
                    "v_value_packed_with_urgency": boolean,
                    "e_executed_with_cta": boolean
                }
            }`
        });
    }

    const payload = {
        model,
        messages,
        max_tokens: 1024,
        temperature: 0.7,
        system: "You are a sales coach helping with the SOLVE framework. Your responses should be in JSON format matching the specified schema."
    };

    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify(payload)
            });

            // Handle rate limiting
            if (response.status === 429) {
                const retryAfter = response.headers.get('Retry-After');
                const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : baseDelay * Math.pow(2, attempt);
                console.warn(`Rate limit reached (attempt ${attempt + 1}/${maxRetries}), waiting ${waitTime/1000} seconds...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
                continue;
            }

            if (response.ok) {
                const result = await response.json();
                console.log('Claude API Response:', {
                    status: response.status,
                    hasContent: !!result.content,
                    timestamp: new Date().toISOString()
                });

                const text = result.content;
                if (!text) {
                    console.error('Empty response from Claude:', result);
                    throw new Error('Empty response from API');
                }

                if (isFinalCall) {
                    return { text, status: { S: true, O: true, L: true, V: true, E: true } };
                }

                try {
                    // Clean and parse the JSON response
                    const cleanedText = text.replace(/```json\n?|```/g, '').trim();
                    const parsed = JSON.parse(cleanedText);
                    
                    const status = {
                        S: !!parsed.solve_status?.s_spotted_pain_point,
                        O: !!parsed.solve_status?.o_outlined_specific_outcome,
                        L: !!parsed.solve_status?.l_limited_risk_with_guarantees,
                        V: !!parsed.solve_status?.v_value_packed_with_urgency,
                        E: !!parsed.solve_status?.e_executed_with_cta,
                    };
                    return { text: parsed.persona_response, status };
                } catch (e) {
                    console.error("JSON parsing error:", {
                        error: e.name,
                        message: e.message,
                        rawText: text.substring(0, 200) + '...'
                    });
                    throw new Error('Could not parse the AI response. Please try again.');
                }
            } else {
                const errorText = await response.text();
                console.error('Claude API Error:', {
                    status: response.status,
                    error: errorText,
                    attempt: attempt + 1
                });
                
                if (attempt === maxRetries - 1) {
                    throw new Error(`API Error (${response.status}): ${errorText}`);
                }
            }
        } catch (error) {
            console.error("Network or parsing error:", {
                error: error.message,
                attempt: attempt + 1,
                maxRetries
            });
            
            if (attempt === maxRetries - 1) {
                throw error;
            }

            const waitTime = baseDelay * Math.pow(2, attempt);
            console.warn(`Retrying in ${waitTime/1000} seconds...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
    }
    
    throw new Error("Failed to get response after multiple retries");
};

// [Rest of the component code remains the same, just replace callGemini with callClaude in your event handlers]